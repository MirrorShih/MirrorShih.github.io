{"title":"OpenGL 互動式水面","uid":"a11c75e48c01d98b9140b0a89daedced","slug":"OpenGL-互動式水面","date":"2022-02-06T08:48:18.000Z","updated":"2025-04-19T10:20:09.082Z","comments":true,"path":"api/articles/OpenGL-互動式水面.json","keywords":null,"cover":"/post/OpenGL-互動式水面/cover.png","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>會想寫這篇文章其實有一個契機，我在讀<a href=\"https://madebyevan.com/webgl-water/\">WebGL Water</a> 的source code時，其中有一段程式碼中提到了 ping-pong rendering，不過在我自己搜尋資料時卻發現相關的技術幾乎沒有人對它進行比較詳細的解釋，在跟朋友抱怨這件事後，他說：「既然沒有人寫那你就可以寫一篇阿。」於是這篇文章就這樣誕生了。雖然說是OpenGL互動式水面，但這篇文章不會將重點放在實作細節上，會有很大一部分是WebGL Water source code導讀。</p>\n<h1 id=\"目標受衆\"><a href=\"#目標受衆\" class=\"headerlink\" title=\"目標受衆\"></a>目標受衆</h1><ul>\n<li>OpenGL/WebGL新手，想了解用GL製作水面的方式</li>\n<li>正在台科電腦圖學導論痛苦掙扎的你</li>\n</ul>\n<h1 id=\"先備知識\"><a href=\"#先備知識\" class=\"headerlink\" title=\"先備知識\"></a>先備知識</h1><p>在看這篇文章之前，最好對下列的技術有一定程度的了解：</p>\n<ul>\n<li>OpenGL/WebGL（廢話）</li>\n<li>FrameBuffer Object</li>\n<li>Shader</li>\n</ul>\n<hr>\n<p>那就讓我們開始吧</p>\n<h1 id=\"Height-map\"><a href=\"#Height-map\" class=\"headerlink\" title=\"Height map\"></a>Height map</h1><p>首先我們要引入一個概念<strong>Height map</strong>，Height map的概念是將一張圖片的顏色（ex:rgb）當作水面的高度，這裏我以一張灰階圖爲例<br><img src=\"/post/OpenGL-%E4%BA%92%E5%8B%95%E5%BC%8F%E6%B0%B4%E9%9D%A2/water_gray.png\"><br>我們先建一個有很多vertex的平面，將這張圖當作texture丟進vertex shader中，並在vertex shader中讀取這張圖的顏色（是灰階圖所以rgb相同，擇一即可），對當前的高度加上顏色的值，就能得到一個不平整的水面，這裏我們來看看WebGL Water是怎麼實作的</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">uniform sampler2D water;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">varying vec3 position;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void main() {</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">position = gl_Vertex.xzy;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">position.y += info.r;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">}</span></span></code></pre></div><p>用上圖面那張圖做出來的效果：<br><img src=\"/post/OpenGL-%E4%BA%92%E5%8B%95%E5%BC%8F%E6%B0%B4%E9%9D%A2/water_gray_example.png\"></p>\n<p>想象如果我們擁有一連串的水流動的灰階圖，按照順序畫出來，就可以模擬出水流動的效果了！</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>如果想要對這個平面染上水的顏色<br>記得要算normal<br>對不同高度的地方染不同的顏色<br>否則人眼會很難看出高度差</p>\n</div>\n<h1 id=\"Picking\"><a href=\"#Picking\" class=\"headerlink\" title=\"Picking\"></a>Picking</h1><p>再來我們來談談OpenGL中要如何實作滑鼠選取的功能，在OpenGL中我們可以使用下列兩種做法：  </p>\n<ul>\n<li>Ray tracing</li>\n<li>Shader</li>\n</ul>\n<p>閱讀WebGL Water的source code可以發現他是選擇第一種方式來做，但今天我們這篇文章會把重點放在第二種做法上。  </p>\n<hr>\n<p>先解釋一下兩者的差別，Ray tracing是從滑鼠點擊的位置打出一條ray，用那條ray跟場景上的物件的面做intersection來判斷ray打到的位置，在場景上有很多面需要做intersection時計算量就會增加，而且實作起來也不是很容易。</p>\n<hr>\n<p>再來就是今天要介紹的方法，這個方法使用Shader來達成，相信讀者看到這可能會有一個疑問，Shader不是用來輸出的嗎？？？沒錯，而我們就是要使用輸出顏色的方式來達成選取的功能。  </p>\n<p>要怎麼做呢？<br>其實很簡單，<br>我們開一個FrameBuffer Object（以下簡稱FBO），在裏面畫上水的平面，但這次我們要在fragment shader中將顏色畫成平面的texture coordinate。  </p>\n<p>如下圖所示<br><img src=\"/post/OpenGL-%E4%BA%92%E5%8B%95%E5%BC%8F%E6%B0%B4%E9%9D%A2/water_pick.png\"></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">#version 430 core</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">out vec4 f_color;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">in V_OUT</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">{</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">   vec3 position;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">   vec3 normal;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">   vec2 texture_coordinate;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">} f_in;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void main()</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">{   </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    vec3 color = vec3(f_in.texture_coordinate.x,f_in.texture_coordinate.y,0.1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    f_color = vec4(color, 1.0f);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">}</span></span></code></pre></div><p>再來我們我們使用glReadPixels()來讀取滑鼠點擊位置的顏色，就能夠判斷點到的位置在水面上的相對位置了</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #82AAFF\">glBindFramebuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_READ_FRAMEBUFFER</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> framebufferPick</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glReadBuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_COLOR_ATTACHMENT0</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">glm</span><span style=\"color: #89DDFF\">::</span><span style=\"color: #BABED8\">vec3 uv</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glReadPixels</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">mouse_x</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> mouse_y</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> GL_RGB</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> GL_FLOAT</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&amp;</span><span style=\"color: #BABED8\">uv</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">]);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glReadBuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_NONE</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glBindFramebuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_READ_FRAMEBUFFER</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">);</span></span></code></pre></div><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>在輸出顏色時我們選擇將b設成固定的0.1<br>並在每次畫FBO時glClearColor()將b設成0.0<br>後續判斷點擊的顏色時則可透過b的值來判斷是否有點擊到水面<br>若b值爲0.0則無<br>爲0.1則有</p>\n</div>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>在讀取滑鼠點擊位置的pixel時<br>要注意滑鼠的xy可能和水面貼圖的xy方向不一<br>需要根據情況調整傳入的滑鼠位置數值</p>\n</div>\n<h1 id=\"Ping-Pong-Rendering\"><a href=\"#Ping-Pong-Rendering\" class=\"headerlink\" title=\"Ping-Pong Rendering\"></a>Ping-Pong Rendering</h1><p>處理完點擊的功能了，接下來我們就來看看如何讓水產生漣漪吧。這裏就不得不提到此文誕生的原因，WebGL Water使用的ping-pong rendering。</p>\n<hr>\n<p>Ping-Pong Rendering其實是一個在實作上才需要使用的技術，今天我們想要計算水面漣漪的動態過程，我們需要前一張水面漣漪圖來當作下一張漣漪的輸入，透過前一張的高度來計算下一張的高度，Ping-Pong Rendering就是這個可以把每一次的畫面丟給下一次當輸入的技巧。<strong>江湖一點訣，講破毋值三仙錢。</strong>那我們就來看看要怎麼做吧。</p>\n<hr>\n<p>首先這個技巧的核心就是FBO render to texture的能力，我們會開兩個FBO，先畫FBO1，然後將FBO1輸出的那個texture丟到FBO2中當作輸入的texture，這時我們就能在FBO2中用shader來對前一張texture做想要的操作了。在FBO2中輸出的結果又可以丟回FBO1中當輸入，就像打乒乓球一樣。<br><img src=\"/post/OpenGL-%E4%BA%92%E5%8B%95%E5%BC%8F%E6%B0%B4%E9%9D%A2/ping_pong.png\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p>Ping-Pong Rendering適用在後面的texture依賴前面texture的情況<br>舉一個常見的例子<br>Gaussian Blur就是使用Ping-Pong Rendering的好地方</p>\n</div>\n<h1 id=\"漣漪\"><a href=\"#漣漪\" class=\"headerlink\" title=\"漣漪\"></a>漣漪</h1><p>學會了Ping-Pong Rendering，我們終於可以來繪製漣漪了，我們來看看WebGL Water是怎麼實作的。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>如果你是使用OpenGL，<br>那此處需要注意你開的texture要可以進行浮點數運算，<br>在WebGL中他是使用gl.RGBA的形式，<br>但在OpenGL中要使用如GL_RGB32F的internal format</p>\n</div>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">uniform sampler2D texture;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">uniform vec2 delta;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">varying vec2 coord;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void main() {</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* get vertex info */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  vec4 info = texture2D(texture, coord);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* calculate average neighbor height */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  vec2 dx = vec2(delta.x, 0.0);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  vec2 dy = vec2(0.0, delta.y);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  float average = (</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    texture2D(texture, coord - dx).r +</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    texture2D(texture, coord - dy).r +</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    texture2D(texture, coord + dx).r +</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    texture2D(texture, coord + dy).r</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  ) * 0.25;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* change the velocity to move toward the average */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  info.g += (average - info.r) * 2.0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* attenuate the velocity a little so waves do not last forever */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  info.g *= 0.995;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* move the vertex along the velocity */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  info.r += info.g;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  gl_FragColor = info;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">}</span></span></code></pre></div><p>我們把這個shader當作剛剛提到的Ping-Pong Rendering繪製texture的fragment shader，每次都拿前一張的texture，找當前位置附近高度的平均來當作這次這個位置的高度。</p>\n<hr>\n<p>那現在我們可以模擬漣漪的流動過程了，所以我們需要加一個在滑鼠點擊時產生的漣漪，一樣來看WebGL Water是怎麼做的</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">const float PI = 3.141592653589793;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">uniform sampler2D texture;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">uniform vec2 center;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">uniform float radius;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">uniform float strength;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">varying vec2 coord;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void main() {</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* get vertex info */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  vec4 info = texture2D(texture, coord);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  /* add the drop to the height */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  drop = 0.5 - cos(drop * PI) * 0.5;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  info.r += drop * strength;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  gl_FragColor = info;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">}</span></span></code></pre></div><p>至此，我們就可以產生漣漪了</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #82AAFF\">glBindFramebuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_READ_FRAMEBUFFER</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> framebufferPick</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glReadBuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_COLOR_ATTACHMENT0</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">glm</span><span style=\"color: #89DDFF\">::</span><span style=\"color: #BABED8\">vec3 uv</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glReadPixels</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">mouse_x</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> mouse_y</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> GL_RGB</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> GL_FLOAT</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&amp;</span><span style=\"color: #BABED8\">uv</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">]);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glReadBuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_NONE</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">glBindFramebuffer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">GL_READ_FRAMEBUFFER</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF; font-style: italic\">if</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">uv</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #BABED8\">z </span><span style=\"color: #89DDFF\">!=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0.0</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">{</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #89DDFF\">this-&gt;</span><span style=\"color: #82AAFF\">addDrop</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">glm</span><span style=\"color: #89DDFF\">::</span><span style=\"color: #82AAFF\">vec2</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">uv</span><span style=\"color: #89DDFF\">));</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">}</span></span></code></pre></div><p>在addDrop function中，我們就把Ping-Pong Rendering那兩個FBO的texture拿出來用產生漣漪的shader畫一次，然後丟回去繼續update就可以了。<br><img src=\"/post/OpenGL-%E4%BA%92%E5%8B%95%E5%BC%8F%E6%B0%B4%E9%9D%A2/cover.png\"></p>\n","feature":true,"text":"前言會想寫這篇文章其實有一個契機，我在讀WebGL Water 的source code時，其中有一段程式碼中提到了 ping-pong rendering，不...","permalink":"/post/OpenGL-互動式水面","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","count":1,"path":"api/categories/Computer-Graphics.json"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","count":1,"path":"api/tags/Computer-Graphics.json"},{"name":"OpenGL","slug":"OpenGL","count":1,"path":"api/tags/OpenGL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A8%99%E5%8F%97%E8%A1%86\"><span class=\"toc-text\">目標受衆</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%88%E5%82%99%E7%9F%A5%E8%AD%98\"><span class=\"toc-text\">先備知識</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Height-map\"><span class=\"toc-text\">Height map</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Picking\"><span class=\"toc-text\">Picking</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Ping-Pong-Rendering\"><span class=\"toc-text\">Ping-Pong Rendering</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BC%A3%E6%BC%AA\"><span class=\"toc-text\">漣漪</span></a></li></ol>","author":{"name":"Mirror","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/42204820","link":"/","description":"We are all in the gutter but some of us are looking at the stars","socials":{"github":"https://github.com/MirrorShih","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/svg/email.svg","link":"mailto:mirrorshih@gmail.com"},"linkedin":{"icon":"/svg/linkedin.svg","link":"https://www.linkedin.com/in/chia-chun-shih/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"2023資工系普通人軟體工程師實習面試心得","uid":"4d768e66d6ff3b2864999d92bce4a845","slug":"2023資工系普通人軟體工程師實習面試心得","date":"2023-07-01T08:31:29.000Z","updated":"2024-04-23T13:53:12.888Z","comments":true,"path":"api/articles/2023資工系普通人軟體工程師實習面試心得.json","keywords":null,"cover":"/post/2023資工系普通人軟體工程師實習面試心得/cover.png","text":"前言因為在找實習時很愛看前人們分享的找實習經驗，也受到很多幫助，因此決定來寫一篇我自己的實習面試經驗，在開始時想先跟讀這篇文章的大家說，如果你現在是剛踏入這個領...","permalink":"/post/2023資工系普通人軟體工程師實習面試心得","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Internship","slug":"Internship","count":1,"path":"api/categories/Internship.json"}],"tags":[{"name":"Internship","slug":"Internship","count":1,"path":"api/tags/Internship.json"}],"author":{"name":"Mirror","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/42204820","link":"/","description":"We are all in the gutter but some of us are looking at the stars","socials":{"github":"https://github.com/MirrorShih","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/svg/email.svg","link":"mailto:mirrorshih@gmail.com"},"linkedin":{"icon":"/svg/linkedin.svg","link":"https://www.linkedin.com/in/chia-chun-shih/"}}}},"feature":true},"next_post":{"title":"關於我學習資安的那些事","uid":"c5f4ff86e66107732daa461670b5aeaf","slug":"關於我學習資安的那些事","date":"2022-03-23T07:47:30.000Z","updated":"2025-04-19T10:19:06.984Z","comments":true,"path":"api/articles/關於我學習資安的那些事.json","keywords":null,"cover":"/post/關於我學習資安的那些事/cover.png","text":"相信有很多對資工領域有興趣或已就讀於相關科系的學生，或多或少的都有聽過資安或CTF這幾個字，想入門卻不得其道，今天這篇文章我想想談談我個人在資安領域摸索的小心得...","permalink":"/post/關於我學習資安的那些事","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Security","slug":"Security","count":1,"path":"api/categories/Security.json"}],"tags":[{"name":"Security","slug":"Security","count":1,"path":"api/tags/Security.json"}],"author":{"name":"Mirror","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/42204820","link":"/","description":"We are all in the gutter but some of us are looking at the stars","socials":{"github":"https://github.com/MirrorShih","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"email":{"icon":"/svg/email.svg","link":"mailto:mirrorshih@gmail.com"},"linkedin":{"icon":"/svg/linkedin.svg","link":"https://www.linkedin.com/in/chia-chun-shih/"}}}},"feature":false}}