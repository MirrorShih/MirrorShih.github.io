[{"id":"c5f4ff86e66107732daa461670b5aeaf","title":"關於我學習資安的那些事","content":"相信有很多對資工領域有興趣或已就讀於相關科系的學生，或多或少的都有聽過資安或CTF這幾個字，想入門卻不得其道，今天這篇文章我想想談談我個人在資安領域摸索的小心得。\n\n0x00 故事的開始相信很多人對資訊安全沒什麼概念，但大家應該都聽過「駭客」這兩個字，沒錯，當年不熟悉資安的我也是對這樣的稱號充滿憧憬，對於這樣的學生，在剛觸碰資安技術時，會發生什麼呢？沒錯，就是嘗試尋找一些現成的網站打打看。在此我非常不推薦對於資安有興趣的新手跟當時的我做一樣的事情，不過這就是我當時開始的地方。  \n\n那時的我，第一個盯上的就是學校的網站，在當時，網站使用學生個人的相關資訊做為學生帳號的密碼，但學生的資料在很多地方是公開的，只要蒐集資料，再加以窮舉，就有機會以他人的身份登入系統（在此我也非常不推薦網站系統使用不可更改且跟使用者身份相關的預設密碼），大約一週後，我已經擁有校內絕大多數學生的登入權限。\n\n雖然我並不建議資安新手去隨便亂打網站，但我分享這個故事，是因為我覺得有一個很重要的觀點值得思考：當我手上有一些資訊，他看起來可能沒有很有用，但當我們從另一個角度看這些資訊，就能利用這些資訊達成目的。在經過了一個月的努力後，我更進一步的發現了當時系統甚至存在明文密碼以及權限管理不當的問題，甚至擁有上傳下載和修改網站資料的權限。\n\n0x01 漏洞回報？攻擊結束的下一步打完網站了，那……現在到底該做什麼？上一段提到的「駭客」，其實並不完全是大家想象中的攻擊者，利用漏洞從事不法行為的人，事實上駭客也是有分成利用漏洞的壞人和保護系統的好人，在系統設計之初就設計出一個安全的系統是非常困難的，因此我們需要請一些駭客來攻擊我們的網站，再將他們找出的漏洞修復，如果駭客發現了一些全新的攻擊手法，也可以將其公開分享，與世界各地的好手交流，讓往後的網路世界更加安全，因此駭客們也是保護我們資安的重要推手。當年的我依樣畫葫蘆做了一樣的事情，我將學校系統漏洞的問題反饋給我當時的班導，並透過他跟學校的相關處室談這件事，後來校方也將這個問題修復。\n\n0x02 我也想入門資安，該怎麼做？上文中我說我非常不推薦大家拿他人的網站練手，也有很多人根本連要怎麼上手都不了解，這邊我非常推薦可以先從打CTF開始。CTF全名是Capture The Flag，是模擬攻擊手法的一種遊戲，玩家可以分析漏洞並對其進行攻擊，成功後能夠獲得Flag，通常是一串文字，代表你成功解開這個精心設計的題目。雖然CTF並不能完全呈現現實世界攻防的情況，但作為培養資安知識的手段也非常足夠了。在一些更進階的CTF比賽中，出題者甚至能夠釋出那些需要思考全新攻擊手法才能夠解開的題目。關於CTF的其他細節我就不贅述太多，留給各位讀者自己摸索吧。（文末我會放一些適合新手的入門資訊）\n\n0x03 故事的下一個篇章事實上，現實世界中處處充滿了資安問題，即便你不是一個資安領域的研究者，也要對個人資安保護有一些基礎的知識。如今AI議題熱門，但即便是用AI解決問題也充斥了資安議題，近期也有很多研究是對深度學習的類神經網路進行攻擊，想象有一天你開自駕車出門，但卻因前方車輛的車牌被人惡意修改過，導致你的車並未發現前方車輛，就有可能發生意外，因此我認為資安議題會隨著時間不斷更新，永遠沒有結束的一天。近期我也打算投入類神經網路對惡意軟體檢測的研究，再從惡意軟體的角度來嘗試能否攻擊類神經網路，避開類神經網路的檢測。\n\n0x04 學習資源\nCTF\npicoCTF\n\n\n學習資料\nAwesome-Hacking\nawesome-cs-training\n\n\n培訓活動\nAIS3\n教育部資訊安全人才培育計畫\n\n\n競賽\n金盾獎\n\n\n社團\n台科資安社\n\n\n\n","slug":"關於我學習資安的那些事","date":"2022-03-23T07:47:30.000Z","categories_index":"Security","tags_index":"Security","author_index":"Mirror"},{"id":"a11c75e48c01d98b9140b0a89daedced","title":"OpenGL 互動式水面","content":"前言會想寫這篇文章其實有一個契機，我在讀WebGL Water 的source code時，其中有一段程式碼中提到了 ping-pong rendering，不過在我自己搜尋資料時卻發現相關的技術幾乎沒有人對它進行比較詳細的解釋，在跟朋友抱怨這件事後，他說：「既然沒有人寫那你就可以寫一篇阿。」於是這篇文章就這樣誕生了。雖然說是OpenGL互動式水面，但這篇文章不會將重點放在實作細節上，會有很大一部分是WebGL Water source code導讀。\n目標受衆\nOpenGL/WebGL新手，想了解用GL製作水面的方式\n正在台科電腦圖學導論痛苦掙扎的你\n\n先備知識在看這篇文章之前，最好對下列的技術有一定程度的了解：\n\nOpenGL/WebGL（廢話）\nFrameBuffer Object\nShader\n\n\n那就讓我們開始吧\nHeight map首先我們要引入一個概念Height map，Height map的概念是將一張圖片的顏色（ex:rgb）當作水面的高度，這裏我以一張灰階圖爲例我們先建一個有很多vertex的平面，將這張圖當作texture丟進vertex shader中，並在vertex shader中讀取這張圖的顏色（是灰階圖所以rgb相同，擇一即可），對當前的高度加上顏色的值，就能得到一個不平整的水面，這裏我們來看看WebGL Water是怎麼實作的\nuniform sampler2D water;\nvarying vec3 position;\nvoid main() {\nvec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);\nposition = gl_Vertex.xzy;\nposition.y += info.r;\ngl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\n}\n用上圖面那張圖做出來的效果：\n想象如果我們擁有一連串的水流動的灰階圖，按照順序畫出來，就可以模擬出水流動的效果了！\n\n\n\n\n\n\n\nWARNING\n如果想要對這個平面染上水的顏色記得要算normal對不同高度的地方染不同的顏色否則人眼會很難看出高度差\n\nPicking再來我們來談談OpenGL中要如何實作滑鼠選取的功能，在OpenGL中我們可以使用下列兩種做法：  \n\nRay tracing\nShader\n\n閱讀WebGL Water的source code可以發現他是選擇第一種方式來做，但今天我們這篇文章會把重點放在第二種做法上。  \n\n先解釋一下兩者的差別，Ray tracing是從滑鼠點擊的位置打出一條ray，用那條ray跟場景上的物件的面做intersection來判斷ray打到的位置，在場景上有很多面需要做intersection時計算量就會增加，而且實作起來也不是很容易。\n\n再來就是今天要介紹的方法，這個方法使用Shader來達成，相信讀者看到這可能會有一個疑問，Shader不是用來輸出的嗎？？？沒錯，而我們就是要使用輸出顏色的方式來達成選取的功能。  \n要怎麼做呢？其實很簡單，我們開一個FrameBuffer Object（以下簡稱FBO），在裏面畫上水的平面，但這次我們要在fragment shader中將顏色畫成平面的texture coordinate。  \n如下圖所示\n#version 430 core\nout vec4 f_color;\n\nin V_OUT\n{\n   vec3 position;\n   vec3 normal;\n   vec2 texture_coordinate;\n} f_in;\n\nvoid main()\n{   \n    vec3 color = vec3(f_in.texture_coordinate.x,f_in.texture_coordinate.y,0.1);\n    f_color = vec4(color, 1.0f);\n}\n再來我們我們使用glReadPixels()來讀取滑鼠點擊位置的顏色，就能夠判斷點到的位置在水面上的相對位置了\nglBindFramebuffer(GL_READ_FRAMEBUFFER, framebufferPick);\nglReadBuffer(GL_COLOR_ATTACHMENT0);\n\nglm::vec3 uv;\nglReadPixels(mouse_x, mouse_y, 1, 1, GL_RGB, GL_FLOAT, &amp;uv[0]);\n\nglReadBuffer(GL_NONE);\nglBindFramebuffer(GL_READ_FRAMEBUFFER, 0);\n\n\n\n\n\n\n\nTIP\n在輸出顏色時我們選擇將b設成固定的0.1並在每次畫FBO時glClearColor()將b設成0.0後續判斷點擊的顏色時則可透過b的值來判斷是否有點擊到水面若b值爲0.0則無爲0.1則有\n\n\n\n\n\n\n\n\nWARNING\n在讀取滑鼠點擊位置的pixel時要注意滑鼠的xy可能和水面貼圖的xy方向不一需要根據情況調整傳入的滑鼠位置數值\n\nPing-Pong Rendering處理完點擊的功能了，接下來我們就來看看如何讓水產生漣漪吧。這裏就不得不提到此文誕生的原因，WebGL Water使用的ping-pong rendering。\n\nPing-Pong Rendering其實是一個在實作上才需要使用的技術，今天我們想要計算水面漣漪的動態過程，我們需要前一張水面漣漪圖來當作下一張漣漪的輸入，透過前一張的高度來計算下一張的高度，Ping-Pong Rendering就是這個可以把每一次的畫面丟給下一次當輸入的技巧。江湖一點訣，講破毋值三仙錢。那我們就來看看要怎麼做吧。\n\n首先這個技巧的核心就是FBO render to texture的能力，我們會開兩個FBO，先畫FBO1，然後將FBO1輸出的那個texture丟到FBO2中當作輸入的texture，這時我們就能在FBO2中用shader來對前一張texture做想要的操作了。在FBO2中輸出的結果又可以丟回FBO1中當輸入，就像打乒乓球一樣。\n\n\n\n\n\n\nTIP\nPing-Pong Rendering適用在後面的texture依賴前面texture的情況舉一個常見的例子Gaussian Blur就是使用Ping-Pong Rendering的好地方\n\n漣漪學會了Ping-Pong Rendering，我們終於可以來繪製漣漪了，我們來看看WebGL Water是怎麼實作的。\n\n\n\n\n\n\n\nWARNING\n如果你是使用OpenGL，那此處需要注意你開的texture要可以進行浮點數運算，在WebGL中他是使用gl.RGBA的形式，但在OpenGL中要使用如GL_RGB32F的internal format\n\nuniform sampler2D texture;\nuniform vec2 delta;\nvarying vec2 coord;\nvoid main() {\n  /* get vertex info */\n  vec4 info = texture2D(texture, coord);\n  \n  /* calculate average neighbor height */\n  vec2 dx = vec2(delta.x, 0.0);\n  vec2 dy = vec2(0.0, delta.y);\n  float average = (\n    texture2D(texture, coord - dx).r +\n    texture2D(texture, coord - dy).r +\n    texture2D(texture, coord + dx).r +\n    texture2D(texture, coord + dy).r\n  ) * 0.25;\n  \n  /* change the velocity to move toward the average */\n  info.g += (average - info.r) * 2.0;\n  \n  /* attenuate the velocity a little so waves do not last forever */\n  info.g *= 0.995;\n  \n  /* move the vertex along the velocity */\n  info.r += info.g;\n  \n  gl_FragColor = info;\n}\n\n我們把這個shader當作剛剛提到的Ping-Pong Rendering繪製texture的fragment shader，每次都拿前一張的texture，找當前位置附近高度的平均來當作這次這個位置的高度。\n\n那現在我們可以模擬漣漪的流動過程了，所以我們需要加一個在滑鼠點擊時產生的漣漪，一樣來看WebGL Water是怎麼做的\nconst float PI = 3.141592653589793;\nuniform sampler2D texture;\nuniform vec2 center;\nuniform float radius;\nuniform float strength;\nvarying vec2 coord;\nvoid main() {\n  /* get vertex info */\n  vec4 info = texture2D(texture, coord);\n  \n  /* add the drop to the height */\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\n  drop = 0.5 - cos(drop * PI) * 0.5;\n  info.r += drop * strength;\n  \n  gl_FragColor = info;\n}\n至此，我們就可以產生漣漪了\nglBindFramebuffer(GL_READ_FRAMEBUFFER, framebufferPick);\nglReadBuffer(GL_COLOR_ATTACHMENT0);\n\nglm::vec3 uv;\nglReadPixels(mouse_x, mouse_y, 1, 1, GL_RGB, GL_FLOAT, &amp;uv[0]);\n\nglReadBuffer(GL_NONE);\nglBindFramebuffer(GL_READ_FRAMEBUFFER, 0);\nif (uv.z != 0.0)\n{\n    this-&gt;addDrop(glm::vec2(uv));\n}\n在addDrop function中，我們就把Ping-Pong Rendering那兩個FBO的texture拿出來用產生漣漪的shader畫一次，然後丟回去繼續update就可以了。\n","slug":"OpenGL-互動式水面","date":"2022-02-06T08:48:18.000Z","categories_index":"Computer Graphics","tags_index":"Computer Graphics,OpenGL","author_index":"Mirror"}]